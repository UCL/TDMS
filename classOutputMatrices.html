<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TDMS: OutputMatrices Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TDMS
   </div>
   <div id="projectbrief">Time Domain Maxwell Solver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classOutputMatrices.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classOutputMatrices-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OutputMatrices Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9a00c71272b4a9be5f487f288b33d8b"><td class="memItemLeft" align="right" valign="top">mxArray *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#ac9a00c71272b4a9be5f487f288b33d8b">operator[]</a> (int index)</td></tr>
<tr class="memdesc:ac9a00c71272b4a9be5f487f288b33d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a (pointer to a) MATLAB output matrix by index reference.  <a href="classOutputMatrices.html#ac9a00c71272b4a9be5f487f288b33d8b">More...</a><br /></td></tr>
<tr class="separator:ac9a00c71272b4a9be5f487f288b33d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8ac1c10b20fac88378c1f43a307aa8"><td class="memItemLeft" align="right" valign="top">mxArray *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a9d8ac1c10b20fac88378c1f43a307aa8">operator[]</a> (const std::string &amp;matrix_name)</td></tr>
<tr class="memdesc:a9d8ac1c10b20fac88378c1f43a307aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a (pointer to a) MATLAB output matrix by name.  <a href="classOutputMatrices.html#a9d8ac1c10b20fac88378c1f43a307aa8">More...</a><br /></td></tr>
<tr class="separator:a9d8ac1c10b20fac88378c1f43a307aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca51bc3f1b5bbf92254c96cf434015e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a9ca51bc3f1b5bbf92254c96cf434015e">set_matrix_pointer</a> (int index, mxArray *new_ptr)</td></tr>
<tr class="memdesc:a9ca51bc3f1b5bbf92254c96cf434015e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix pointer with the given index.  <a href="classOutputMatrices.html#a9ca51bc3f1b5bbf92254c96cf434015e">More...</a><br /></td></tr>
<tr class="separator:a9ca51bc3f1b5bbf92254c96cf434015e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d1d42f73b1038a66959ea2fc77b48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#ae4d1d42f73b1038a66959ea2fc77b48f">set_matrix_pointer</a> (const std::string &amp;matrix_name, mxArray *new_ptr)</td></tr>
<tr class="memdesc:ae4d1d42f73b1038a66959ea2fc77b48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pointer to the named matrix.  <a href="classOutputMatrices.html#ae4d1d42f73b1038a66959ea2fc77b48f">More...</a><br /></td></tr>
<tr class="separator:ae4d1d42f73b1038a66959ea2fc77b48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a65e6b16ddd7db218c139e999acf513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a8a65e6b16ddd7db218c139e999acf513">set_maxresfield</a> (double maxfield, bool overwrite_existing)</td></tr>
<tr class="memdesc:a8a65e6b16ddd7db218c139e999acf513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maxresfield object. If memory has not been reserved yet, it can be assigned here.  <a href="classOutputMatrices.html#a8a65e6b16ddd7db218c139e999acf513">More...</a><br /></td></tr>
<tr class="separator:a8a65e6b16ddd7db218c139e999acf513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f1770c2fc8737ef3062ed53336e26f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a21f1770c2fc8737ef3062ed53336e26f">allocate_field_and_labels_memory</a> (bool empty_allocation, int I_tot=0, int J_tot=0, int K_tot=0)</td></tr>
<tr class="memdesc:a21f1770c2fc8737ef3062ed53336e26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create MATLAB memory for the field and gridlabel outputs.  <a href="classOutputMatrices.html#a21f1770c2fc8737ef3062ed53336e26f">More...</a><br /></td></tr>
<tr class="separator:a21f1770c2fc8737ef3062ed53336e26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ba9c7e1802bd24438bb08f231526a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a40ba9c7e1802bd24438bb08f231526a0">allocate_Id_memory</a> (bool empty_allocation)</td></tr>
<tr class="memdesc:a40ba9c7e1802bd24438bb08f231526a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create MATLAB memory for the Id structure array.  <a href="classOutputMatrices.html#a40ba9c7e1802bd24438bb08f231526a0">More...</a><br /></td></tr>
<tr class="separator:a40ba9c7e1802bd24438bb08f231526a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0ecf6aacff5d9152318b6bc0552beb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#ace0ecf6aacff5d9152318b6bc0552beb">allocate_campssample_memory</a> (int n_vertices, int n_components, int n_frequencies)</td></tr>
<tr class="memdesc:ace0ecf6aacff5d9152318b6bc0552beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create MATLAB memory for the campssample array.  <a href="classOutputMatrices.html#ace0ecf6aacff5d9152318b6bc0552beb">More...</a><br /></td></tr>
<tr class="separator:ace0ecf6aacff5d9152318b6bc0552beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65525dcc9ecd1da88a6df3528f59dbb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a65525dcc9ecd1da88a6df3528f59dbb6">allocate_interpolation_memory</a> (bool empty_allocation, <a class="el" href="classElectricField.html">ElectricField</a> &amp;E, <a class="el" href="classMagneticField.html">MagneticField</a> &amp;H, Dimension simulation_dimension=THREE)</td></tr>
<tr class="memdesc:a65525dcc9ecd1da88a6df3528f59dbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create MATLAB memory for the gridlabels for the interpolated fields.  <a href="classOutputMatrices.html#a65525dcc9ecd1da88a6df3528f59dbb6">More...</a><br /></td></tr>
<tr class="separator:a65525dcc9ecd1da88a6df3528f59dbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e6b03a5979466a06b883a210bd3296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a62e6b03a5979466a06b883a210bd3296">allocate_extracted_phasor_memory</a> (bool empty_allocation, <a class="el" href="classSurfacePhasors.html">SurfacePhasors</a> &amp;surface_phasors, mxArray *mx_surface_facets)</td></tr>
<tr class="memdesc:a62e6b03a5979466a06b883a210bd3296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create MATLAB memory for the (surface) phasor outputs.  <a href="classOutputMatrices.html#a62e6b03a5979466a06b883a210bd3296">More...</a><br /></td></tr>
<tr class="separator:a62e6b03a5979466a06b883a210bd3296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80233e13a1577efdf231f15ff64cfcce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a80233e13a1577efdf231f15ff64cfcce">save_outputs</a> (std::string output_file_name, bool compressed_output=false)</td></tr>
<tr class="memdesc:a80233e13a1577efdf231f15ff64cfcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the output matrices to the output file.  <a href="classOutputMatrices.html#a80233e13a1577efdf231f15ff64cfcce">More...</a><br /></td></tr>
<tr class="separator:a80233e13a1577efdf231f15ff64cfcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a44cdabbe7b0e17b6e4d7ec85515f8748"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a44cdabbe7b0e17b6e4d7ec85515f8748">index_from_matrix_name</a> (const std::string &amp;matrix_name)</td></tr>
<tr class="memdesc:a44cdabbe7b0e17b6e4d7ec85515f8748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the index of matrix_name in the tdms_matrix_names::matrixnames array.  <a href="classOutputMatrices.html#a44cdabbe7b0e17b6e4d7ec85515f8748">More...</a><br /></td></tr>
<tr class="separator:a44cdabbe7b0e17b6e4d7ec85515f8748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52346676ecc12200f221c5d8673ea356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a52346676ecc12200f221c5d8673ea356">memory_already_assigned</a> (std::vector&lt; std::string &gt; matrix_names)</td></tr>
<tr class="memdesc:a52346676ecc12200f221c5d8673ea356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the matrix_pointer corresponding to any one of the matrix names passed already points to allocated memory.  <a href="classOutputMatrices.html#a52346676ecc12200f221c5d8673ea356">More...</a><br /></td></tr>
<tr class="separator:a52346676ecc12200f221c5d8673ea356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca5b56e0c529ed03ac1150873a092ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a6ca5b56e0c529ed03ac1150873a092ce">memory_already_assigned</a> (std::string matrix_name)</td></tr>
<tr class="memdesc:a6ca5b56e0c529ed03ac1150873a092ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the matrix_pointer corresponding to any one of the matrix names passed already points to allocated memory.  <a href="classOutputMatrices.html#a6ca5b56e0c529ed03ac1150873a092ce">More...</a><br /></td></tr>
<tr class="separator:a6ca5b56e0c529ed03ac1150873a092ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c849d3a031c1e4d423c70a1a6c81398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a3c849d3a031c1e4d423c70a1a6c81398">error_on_memory_assigned</a> (std::vector&lt; std::string &gt; matrix_names)</td></tr>
<tr class="memdesc:a3c849d3a031c1e4d423c70a1a6c81398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an error if the matrix_pointer corresponding to any one of the matrix names passed already points to allocated memory.  <a href="classOutputMatrices.html#a3c849d3a031c1e4d423c70a1a6c81398">More...</a><br /></td></tr>
<tr class="separator:a3c849d3a031c1e4d423c70a1a6c81398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1a2604014d1fe65eee827c5457233a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#abe1a2604014d1fe65eee827c5457233a">error_on_memory_assigned</a> (std::string matrix_name)</td></tr>
<tr class="memdesc:abe1a2604014d1fe65eee827c5457233a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an error if the matrix_pointer corresponding to any one of the matrix names passed already points to allocated memory.  <a href="classOutputMatrices.html#abe1a2604014d1fe65eee827c5457233a">More...</a><br /></td></tr>
<tr class="separator:abe1a2604014d1fe65eee827c5457233a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d497c75b1c62ca2a18bcbd6e85c155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOutputMatrices.html#a67d497c75b1c62ca2a18bcbd6e85c155">assign_empty_matrix</a> (std::vector&lt; std::string &gt; matrix_names, mxClassID data_type=mxDOUBLE_CLASS, mxComplexity complexity=mxCOMPLEX, int ndims=2)</td></tr>
<tr class="memdesc:a67d497c75b1c62ca2a18bcbd6e85c155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the output matrices provided as empty arrays.  <a href="classOutputMatrices.html#a67d497c75b1c62ca2a18bcbd6e85c155">More...</a><br /></td></tr>
<tr class="separator:a67d497c75b1c62ca2a18bcbd6e85c155"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ada5b85433991d1ce180392c8bff48a16"><td class="memItemLeft" align="right" valign="top"><a id="ada5b85433991d1ce180392c8bff48a16"></a>
mxArray *&#160;</td><td class="memItemRight" valign="bottom"><b>matrix_pointers</b> [NOUTMATRICES_WRITE_ALL] = {nullptr}</td></tr>
<tr class="separator:ada5b85433991d1ce180392c8bff48a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace0ecf6aacff5d9152318b6bc0552beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0ecf6aacff5d9152318b6bc0552beb">&#9670;&nbsp;</a></span>allocate_campssample_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::allocate_campssample_memory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_frequencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create MATLAB memory for the campssample array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_vertices</td><td>Number of vertices we are extracting at. If this is 0, then allocate the empty array </td></tr>
    <tr><td class="paramname">n_components</td><td>Number of amplitude components we are extracting </td></tr>
    <tr><td class="paramname">n_frequencies</td><td>Number of frequencies we are extracting at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62e6b03a5979466a06b883a210bd3296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e6b03a5979466a06b883a210bd3296">&#9670;&nbsp;</a></span>allocate_extracted_phasor_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::allocate_extracted_phasor_memory </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>empty_allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSurfacePhasors.html">SurfacePhasors</a> &amp;&#160;</td>
          <td class="paramname"><em>surface_phasors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxArray *&#160;</td>
          <td class="paramname"><em>mx_surface_facets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create MATLAB memory for the (surface) phasor outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_allocation</td><td>If true, empty arrays will be allocated </td></tr>
    <tr><td class="paramname">surface_phasors</td><td>The surface phasor object handling phasor extraction </td></tr>
    <tr><td class="paramname">mx_surface_facets</td><td>The surface facets to write out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21f1770c2fc8737ef3062ed53336e26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f1770c2fc8737ef3062ed53336e26f">&#9670;&nbsp;</a></span>allocate_field_and_labels_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::allocate_field_and_labels_memory </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>empty_allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>I_tot</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>J_tot</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K_tot</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create MATLAB memory for the field and gridlabel outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_allocation</td><td>If true, empty arrays will be allocated </td></tr>
    <tr><td class="paramname">I_tot,J_tot,K_tot</td><td>The dimensions of the field components (corresponding gridlabel dimensions will be inferred) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40ba9c7e1802bd24438bb08f231526a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ba9c7e1802bd24438bb08f231526a0">&#9670;&nbsp;</a></span>allocate_Id_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::allocate_Id_memory </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>empty_allocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create MATLAB memory for the Id structure array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_allocation</td><td>If true, empty arrays will be allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65525dcc9ecd1da88a6df3528f59dbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65525dcc9ecd1da88a6df3528f59dbb6">&#9670;&nbsp;</a></span>allocate_interpolation_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::allocate_interpolation_memory </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>empty_allocation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classElectricField.html">ElectricField</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMagneticField.html">MagneticField</a> &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dimension&#160;</td>
          <td class="paramname"><em>simulation_dimension</em> = <code>THREE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create MATLAB memory for the gridlabels for the interpolated fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_allocation</td><td>If true, empty arrays will be allocated </td></tr>
    <tr><td class="paramname">E,H</td><td>The {electric,magnetic} field that will be interpolated </td></tr>
    <tr><td class="paramname">simulation_dimension</td><td>Whether we are running a 3D, TE, or TM simulation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67d497c75b1c62ca2a18bcbd6e85c155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d497c75b1c62ca2a18bcbd6e85c155">&#9670;&nbsp;</a></span>assign_empty_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::assign_empty_matrix </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>matrix_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxClassID&#160;</td>
          <td class="paramname"><em>data_type</em> = <code>mxDOUBLE_CLASS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxComplexity&#160;</td>
          <td class="paramname"><em>complexity</em> = <code>mxCOMPLEX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndims</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the output matrices provided as empty arrays. </p>
<p>Outputs are typically set to empty arrays when the user has requested the simulation be run in such a way that the output is not generated, or not requested. We still check for memory leaks before assignment as creating an empty array can still leave MATLAB memory not-cleaned-up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_names</td><td>The list of matrix names to set to be empty. </td></tr>
    <tr><td class="paramname">data_type</td><td>The data type to assign to the empty array (needed for compatability issues) </td></tr>
    <tr><td class="paramname">is_complex</td><td>Whether the data is complex (mxCOMPLEX) or real (mxREAL) </td></tr>
    <tr><td class="paramname">ndims</td><td>Number of dimensions in the empty array to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe1a2604014d1fe65eee827c5457233a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1a2604014d1fe65eee827c5457233a">&#9670;&nbsp;</a></span>error_on_memory_assigned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::error_on_memory_assigned </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>matrix_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an error if the matrix_pointer corresponding to any one of the matrix names passed already points to allocated memory. </p>
<p>This function exists to avoid memory leaks - it is possible for us to reassign the matrix_pointers after mxCreate-ing arrays. To avoid this, we always validate we have not done this before attempting to assign memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_names</td><td>List of output matrices to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c849d3a031c1e4d423c70a1a6c81398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c849d3a031c1e4d423c70a1a6c81398">&#9670;&nbsp;</a></span>error_on_memory_assigned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::error_on_memory_assigned </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>matrix_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw an error if the matrix_pointer corresponding to any one of the matrix names passed already points to allocated memory. </p>
<p>This function exists to avoid memory leaks - it is possible for us to reassign the matrix_pointers after mxCreate-ing arrays. To avoid this, we always validate we have not done this before attempting to assign memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_names</td><td>List of output matrices to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44cdabbe7b0e17b6e4d7ec85515f8748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cdabbe7b0e17b6e4d7ec85515f8748">&#9670;&nbsp;</a></span>index_from_matrix_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OutputMatrices::index_from_matrix_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>matrix_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the index of matrix_name in the tdms_matrix_names::matrixnames array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_name</td><td>The matrix name to locate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The corresponding index </dd></dl>

</div>
</div>
<a id="a6ca5b56e0c529ed03ac1150873a092ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca5b56e0c529ed03ac1150873a092ce">&#9670;&nbsp;</a></span>memory_already_assigned() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OutputMatrices::memory_already_assigned </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>matrix_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the matrix_pointer corresponding to any one of the matrix names passed already points to allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_names</td><td>List of output matrices to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52346676ecc12200f221c5d8673ea356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52346676ecc12200f221c5d8673ea356">&#9670;&nbsp;</a></span>memory_already_assigned() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OutputMatrices::memory_already_assigned </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>matrix_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the matrix_pointer corresponding to any one of the matrix names passed already points to allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_names</td><td>List of output matrices to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d8ac1c10b20fac88378c1f43a307aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8ac1c10b20fac88378c1f43a307aa8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mxArray* &amp; OutputMatrices::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>matrix_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch a (pointer to a) MATLAB output matrix by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_name</td><td>Name of the matrix to fetch the pointer to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mxArray* Pointer to the corresponding MATLAB array </dd></dl>

</div>
</div>
<a id="ac9a00c71272b4a9be5f487f288b33d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a00c71272b4a9be5f487f288b33d8b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mxArray* &amp; OutputMatrices::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch a (pointer to a) MATLAB output matrix by index reference. </p>
<p>Index-references can be computed through index_from_matrix_name. They are ordered in the same way as the names in tdms_matrix_names::matrixnames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to fetch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mxArray* Pointer to the corresponding MATLAB array </dd></dl>

</div>
</div>
<a id="a80233e13a1577efdf231f15ff64cfcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80233e13a1577efdf231f15ff64cfcce">&#9670;&nbsp;</a></span>save_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::save_outputs </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>output_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the output matrices to the output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_file_name</td><td>The file to write the simulation outputs to </td></tr>
    <tr><td class="paramname">compressed_output</td><td>If true, write compressed output (do not write facets and vertices) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4d1d42f73b1038a66959ea2fc77b48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d1d42f73b1038a66959ea2fc77b48f">&#9670;&nbsp;</a></span>set_matrix_pointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::set_matrix_pointer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>matrix_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxArray *&#160;</td>
          <td class="paramname"><em>new_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the pointer to the named matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_name</td><td>The name of the matrix that we want to set the pointer to </td></tr>
    <tr><td class="paramname">new_ptr</td><td>The address we want to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ca51bc3f1b5bbf92254c96cf434015e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca51bc3f1b5bbf92254c96cf434015e">&#9670;&nbsp;</a></span>set_matrix_pointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::set_matrix_pointer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mxArray *&#160;</td>
          <td class="paramname"><em>new_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the matrix pointer with the given index. </p>
<p>Not recommended unless you're certain you are setting the correct array pointer! Use the overload which takes the array name as an input if you are uncertain you are setting the correct pointer.</p>
<p>This function mainly sees use during destruction (and output writing) when we just want to iterate over all the matrices that we are dealing with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index in matrix_pointers to set </td></tr>
    <tr><td class="paramname">new_ptr</td><td>The address we want to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a65e6b16ddd7db218c139e999acf513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a65e6b16ddd7db218c139e999acf513">&#9670;&nbsp;</a></span>set_maxresfield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OutputMatrices::set_maxresfield </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxfield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite_existing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maxresfield object. If memory has not been reserved yet, it can be assigned here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxfield</td><td>Value to write to output memory </td></tr>
    <tr><td class="paramname">overwrite_existing</td><td>If true, overwrite existing value (do not assign new memory). Otherwise, create new memory for the maxresfield output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>tdms/include/<a class="el" href="output__matrices_8h_source.html">output_matrices.h</a></li>
<li>tdms/src/output_matrices.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classOutputMatrices.html">OutputMatrices</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
