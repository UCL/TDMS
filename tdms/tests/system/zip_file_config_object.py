import os
from pathlib import Path
from typing import Union


class tdmsCommand:
    """ """

    def __init__(self, input_file: str, output_file: str, flags=[]) -> None:
        self.input_file = input_file
        self.output_file = output_file
        self.flags = flags
        return

    def generate_tdms_command(self) -> list[str]:
        tdms_command = self.flags
        tdms_command.append(self.input_file)
        tdms_command.append(self.output_file)
        return tdms_command


class ZipFileConfig:
    """ """

    def __init__(
        self,
        test_id: Union[str, int],
        zip_link: Union[str, Path],
        other_test_type="cyl",
        fdtd_flag=False,
    ) -> None:

        # Zenodo link to the .zip file
        self.zenodo_link = zip_link
        # Determine the test ID and thus the name of the zip folder to save
        if type(test_id) == int:
            if test_id < 0:
                raise RuntimeError(
                    "{test_id} is not a valid test ID (must be a positive integer or string)"
                )
            elif test_id < 10:
                self.test_id = "arc_0" + str(test_id)
            else:
                self.test_id = "arc_" + str(test_id)
        elif type(test_id) == str:
            self.test_id = "arc_" + test_id
        # build name of zip folder and absolute file path to it
        self.zip_path = Path(
            os.path.dirname(os.path.abspath(__file__)), "new_data", self.zip_folder()
        )

        # This test takes place in free space and with a CYLindrical or SPHerical object
        self.spatial_object_cases = ["fs", other_test_type]

        # Whether this test uses the fdtd method and thus needs to pass this option to tdms
        self.uses_fdtd = fdtd_flag
        return

    def zip_folder(self) -> str:
        """Return the name of the .zip folder that the test data will be located in"""
        return self.test_id + ".zip"

    def solver_method(self) -> str:
        """Returns pstd (psuedo-spectral) or fdtd (finite difference) depending on the solver method this test uses"""
        if self.uses_fdtd:
            return "fdtd"
        else:
            return "pstd"

    def fetch_tdms_flags(self) -> list[str]:
        """Create a list of additional flags that this test must pass to the tdms executable"""
        tdms_flags = []
        if self.uses_fdtd:
            tdms_flags.append("-fd")
        return tdms_flags

    def fetch_input_file(self, spatial_object: str) -> str:
        """Fetches the name of the input file for the test with the given spatial object"""
        return self.solver_method() + "_" + spatial_object + "_input.mat"

    def generate_output_file_name(
        self, spatial_object: str, using_cubic_interpolation: bool
    ) -> str:
        """Creates the name of the output file that will be generated by running tdms on the input file"""
        if using_cubic_interpolation:
            return self.solver_method() + "_" + spatial_object + "_cubic_output.mat"
        else:
            return self.solver_method() + "_" + spatial_object + "_bli_output.mat"

    def fetch_reference_output_filename(
        self, spatial_object: str, using_cubic_interpolation: bool
    ) -> str:
        """Fetches the reference output file corresponding to the given test"""
        if using_cubic_interpolation:
            return self.solver_method() + "_" + spatial_object + "_cubic_reference.mat"
        else:
            return self.solver_method() + "_" + spatial_object + "_bli_reference.mat"

    def generate_tdms_commands(self) -> list[tuple[tdmsCommand, str]]:
        """Generates the commands that will need to be passed to the tdms executable to run all tests associated with this ZipFileConfig object"""
        tdms_commands = []
        # generate the command-line tdms calls
        # these are to be called whilst work(ing)_in_zipped_directory
        for using_cubic_interpolation in [False, True]:
            for spatial_object in self.spatial_object_cases:
                # generate the command-line options to pass to tdms
                tdms_flags = self.fetch_tdms_flags()
                # if we are using cubic interpolation add the command-line flag
                if using_cubic_interpolation:
                    tdms_flags.append("-c")
                command = tdmsCommand(
                    self.fetch_input_file(), self.generate_output_file_name, tdms_flags
                )
                reference = self.fetch_reference_output_filename()
                # append test and reference file to list
                tdms_commands.append([command, reference])
        return
