import os
from io import StringIO
from pathlib import Path
from typing import Tuple, Union

from matlab.engine import MatlabEngine

LOCATION_OF_THIS_FILE = os.path.dirname(os.path.abspath(__file__))


class BScanArguments:
    """Class to tidily contain the input arguments that need to be passed into the MATLAB function of the same name, to generate the input data.

    The bscan/run_bscan.m file contains the matlab function which generates the input data. Regrettably, we need to specify particular inputs to this script for each test, which requires us to translate the argument values as read from the config.yaml file into a long string of values in the correct order, which can in turn be called from matlab.

    BScanArguments is essentially a glorified dictionary, it's members sharing the names of the input arguments to run_bscan. The run_bscan() method of this class calls the MATLAB function of the same name, given a running MATLAB engine.
    """

    # Without these tags in the input_generation field of the config file, we cannot setup the test
    REQUIRED_FIELDS: list[str] = ["input_file"]
    # The defaults for the optional information from the config file
    DEFAULTS: dict[str, Tuple[Union[str, bool, float], type]] = {
        "obstacle": ["fs", str],
        "illsetup": [False, bool],
        "obstacle_radius": [15.0e-6, float],
        "refind": [1.42, float],
        "calc_tdfield": [False, bool],
    }

    # The directory of the test whose input data is being generated
    test_directory: str
    # The name of the .mat file that we are going to produce
    matfile: str

    # The path to the input file that run_bscan is expecting
    input_file: str

    # The obstacle present in the simulation whose input data we are generating
    obstacle: str
    # Flags whether the BScan call requires a call to iteratefdtd_matrix in illsetup mode as well as filesetup mode
    # Default is False
    illsetup: bool
    # Radius of the spatial obstacle in microns (circular face radius for cyl, sphere radius for sph)
    # Default is 15.e-6
    obstacle_radius: float
    # Refractive index of the non-freespace medium.
    # Default 1.42
    refind: float
    # Whether calc_field_tdfield needs to be run prior to setting up the scattering matrix
    calc_tdfield: bool

    def __init__(
        self,
        test_directory: Union[Path, str],
        matfile_to_produce: str,
        config: dict[str, any],
    ) -> None:
        """Initialise by unpacking values from the dictionary generated by the config file."""
        # This information is not in the dictionary we get passed, it is set within each system test itself.
        self.test_directory = str(test_directory)
        self.matfile = matfile_to_produce

        # Keys present in the config file
        keys = config.keys()

        # Check for compulsory inputs, error if not present
        for required_field in self.REQUIRED_FIELDS:
            if required_field not in keys:
                raise RuntimeError(
                    f"Error: required field {required_field} not found in config"
                )
        # Set required fields, which exist if we got to here without throwing an error
        # Input file [check if file exists beforehand, and preppend the absolute path to the expected location]
        path_to_input_file = Path(LOCATION_OF_THIS_FILE, config["input_file"])
        if not path_to_input_file.exists():
            raise RuntimeError(f"{path_to_input_file} does not exist")
        else:
            self.input_file = str(path_to_input_file)

        # Set optional fields to defaults if not present, or use values provided otherwise
        for optional_value in self.DEFAULTS.keys():
            if (optional_value in keys) and (config[optional_value] != None):
                # Overwrite with value provided in the config file
                # Be sure to cast to the expected datatype beforehand (15e-6 comes in as a str, for example)
                expecting_type = self.DEFAULTS[optional_value][1]
                setattr(self, optional_value, expecting_type(config[optional_value]))
            else:
                # Use default value
                setattr(self, optional_value, self.DEFAULTS[optional_value][0])

        # Setup complete, return
        return

    def _temp_filesetup_name(self) -> str:
        """In the event that illsetup is required for this run, generate the temporary name for the input file to be passed to iteratefdtd_matrix in filesetup mode.

        Only occurs when illumination files are required in input-data regeneration. In this case, self.input_file is passed to iteratefdtd_matrix in 'illsetup' mode.
        """
        # Input file name without the extension (.m)
        raw_input_name = os.path.splitext(self.input_file)[0]
        # Append to filename an suitably unique extension
        raw_input_name += "temp_filesetup_file____.m"
        return raw_input_name

    def _create_temp_filesetup(self) -> None:
        """Generate the tempoaray file to be passed to iteratefdtd_matrix in filesetup mode when an illumination file has also been specified. The "filesetup" mode-file is essentially identical to it's counterpart, but needs the efname and hfname variables TO to be present, but set to empty strings.

        As such, the optimal way to get around this is to have Python copy the input_file (which in this instance is what needs to be used to setup the illumination), and then change the definition of the efname & hfname variables to empty strings in the copied file to create the "filesetup" input.
        """
        # Copy the input_file (illumination-input) line-by-line to a temporary location for the filesetup-input
        # Do not copy across the lines that define the efname and hfname variables
        with open(self.input_file, "r") as illumination_input:
            with open(self._temp_filesetup_name(), "w") as filesetup_input:
                for line in illumination_input:
                    # Remove any potential whitespace padding from the line
                    # This avoids funny business if there's whitespace around the = symbol where {ef,hf}name are defined
                    stripped_line = line.replace(" ", "")
                    # Write line, provided efname or hfname are not defined on it
                    if not (
                        ("efname=" in stripped_line) or ("hfname=" in stripped_line)
                    ):
                        filesetup_input.write(line)
                    elif "efname=" in stripped_line:
                        filesetup_input.write("efname = '';\n")
                    elif "hfname=" in stripped_line:
                        filesetup_input.write("hfname = '';\n")
        # filesetup_input is now ready, and identical to illumination_input save in the definition of efname and hfname
        return

    def run_bscan(self, engine: MatlabEngine) -> Tuple[StringIO, StringIO]:
        """Runs the run_bscan function in the MatlabEngine provided.

        The bscan/ and matlab/ directories are assumed to already be in the includepath of the engine instance, so that the run_bscan and supporting matlab files can be called.

        Returns a tuple of the stdout and stderr from the engine upon executing this command.
        """
        # If illumination file is needed, we need to copy the input file and remove the lines that define the efname and hfname as necessary
        if self.illsetup:
            # If this is true, we need to generate the illumination file from the input file.
            # It is essentially identical, but needs the efname and hfname variables to be:
            # present in the workspace/file when calling with 'illsetup'
            # absent from the workspace/file when calling with 'filesetup'
            # Otherwise, the "input" file to the illsetup and input file for the .mat creation are identical. As such, the optimal way to get around this is to have Python pass the input_file via 'illsetup', then copy this file, remove the definition of the efname & hfname variables, then run 'filesetp' mode. We can then cleanup our "extra" file that we created.
            self._create_temp_filesetup()

        # This dict will pass the additional options to run_bscan.m
        # I know this seems pointless, however when we can make run_bscan a class method everything will be a lot nicer as we won't need to pass into MATLAB here
        options_passed = {
            "obstacle": self.obstacle,
            "illsetup": self.illsetup,
            "ill_filesetup": self._temp_filesetup_name(),
            "obstacle_radius": self.obstacle_radius,
            "refind": self.refind,
            "calc_tdfield": self.calc_tdfield,
            "output_name": self.matfile,
        }

        # prepare IO objects to save polluting the terminal
        stdout_capture = StringIO()
        stderr_capture = StringIO()

        # function [] = run_bscan(test_directory, input_filename, non_fs_obstacle, illfile_extra_file, obstacle_radius, calc_tdfield)
        # pass nargout=0 to indicate no value is to be returned to Python
        engine.run_bscan(
            self.test_directory,
            self.input_file,
            options_passed,
            nargout=0,
            stdout=stdout_capture,
            stderr=stderr_capture,
        )

        # Cleanup the temporary illumination file, if we created it
        if self.illsetup:
            os.remove(self._temp_filesetup_name())
        return stdout_capture, stderr_capture
